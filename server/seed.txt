My question for you is how do you know if changing a CSS property is expensive? Like painting expensive? Not just paint. We're talking layouts, we're talking paint, we're talking composite. These things developers, they talk about this all the time. How do I know if I'm doing something that's going to cause me a bottleneck and it's a problem. How do you know? It's normally just a matter of do it and test it. It was. It was, but it's not anymore, Jake. Good news. I've made a website. Woo! Yes. Dot com. And it's a bit pluggy, isn't it now? This is not like trigger warning? Well, it could be, depending on how upset you get over CSS. Yes, which can be quite upsetting, especially if it's causing performance issues. I like what you did. You brought it right back in. Yeah, anyway. So the idea is you hit the site. It's got all the CSS properties, you can search for the one you're interested in, and it will tell you whether it triggers layout, paint, composite, all of the above. These are different things. Are there things that it would change that only affects one of those things? Give me an example of something that only affects painting, but not the other things. Painting, background size, box shadow, text shadow. They do that because they don't change the layout of the page in any way right? They don't change the geometry of the page. The widths, heights, anything to do with the element's actual sizes. So there are ones that do it the other way around as well? So it's more like a waterfall. If you change layout, which is going to be changing the widths, heights, basically the geometry of the page, paddings, margins, all that kind of stuff. You will change the geometry of the page and that will dirty some pixels, which will need to be repainted and then you'll need to composite the page. Or you change something which causes the paint to happen and you have to composite the page, or you change something which just causes the page to recomposited. So it's a sort of stepping process. When you the state, was this just from memory and experience? Nope. I'm glad you asked. I made the mother of all test suites. It was fantastic. And then I used telemetry to kind of step through them and figure out what was what. But I used will change, which was brand new and very exciting. Basically to say, I will be changing opacity, I will be changing box shadow. You tell me, when I do this, what it triggered. And devtools just went, you know what, I did a bit of layout there. Did a bit of paint. Anyway, if you want to see how your CSS affects performance, what work it's going to trigger, just go to the site and have a look. Oh, cool. And is that for every browser? Other browsers are incoming. Today it's only Chrome. Cool. And what's the site name? I wasn't listening to you properly. Really? No, I really wasn't. You should say it again just for my benefit. Just your benefit? Just my benefit. Excellent. I'm glad we're having this conversation, my friend. Yay! Woo! Keyboards. They're the computer ones or the musical ones. You've used one before, right? I've seen you in the office. Now, I imagine there was a point where a keyboard manufacturer thought, we need to solve this problem. We need to give them a key to press when they've hit the wrong key and they want to undo that error of theirs, right? And they called this the backspace key. Right. So this key that you're supposed to press when you've gone off by one, hit the wrong key, want to correct it. Where did they put this key? Right next to the return/enter key. Right next to the key that says, no actually, everything is great, I want to ship that text off to a colleague. Right? A colleague asked for some help, and I wrote, because I was a little bit busy at the time, give me a sec. And I was like, oh I've done it wrong. Went to press the backspace key. Enter. Off to the colleague. Off to their phone goes, give me a high-five. Like it was a demand. So I want to talk about pointer events. Yay! If you were born at any other point in history, you'd be completely stuffed. I'm full of anti-talents. What would you have done if programming wasn't a thing? Die in a ditch. I would. I really would. It's a really happy tale, isn't it? Yeah. So I want to talk about Pointer events. Right. So the CSS thing where you say, Pointer events none. No, the other one. Because the other spec that they made before, we're going to write a new spec. I know, let's name exactly the same as an existing CSS properties. Yay. No. I'm talking about the events one. Oh. Those, those are brilliant, right? Detailed spec, unifies touch, mouse pointers, and gives you all the everything that you ever need to just bring it all together. Brilliant. It's great. We're not doing it. What? We do have good reasons. It's a really detailed spec. It says the order of all, how everything should happen. But there are performance issues. It's very similar to mouse events. You know when you move a mouse across the screen and you get the mouse move events and the target changes after every element. Yup. Pointer events works in the same way. And that means that as you're doing a touch action, it's going to have to do this hit test throughout the touch. Oh. Big performance problem. You could actually to be fair to them, you can set a capture on it. But then you've still got the enter and leave events on the element that you've captured. That's a big performance no-no. And the unification stuff that you mentioned Yay. It's not as good as you think. Oh. I don't know about you, but whenever I use touch events, which we already have, I usually use it because I want something special to happen with touch. Yeah. Like a swipe action, or something that I wouldn't want to do with the mouse. Right. And that's what I find most of the time, that there are occasions, maybe like a drag and drop action, where you'd want touch and mouse doing the same thing. But mostly, not that. OK. And there are also features that it stops as well. So pointer events, what seems like another plus point for them, is it's either the user agent, the browser, dealing with the touch stuff or you. No in between. So if it starts scrolling, you're out of the picture. But we have features that need that. For instance, you're scrolling. You scroll to the top. And then you drag down. Pull to refresh? Pull to refresh. So that's you letting the user agent do part of it. And then you want to take over at that point. You can't do that with pointer events. Oh. That's horrible. Right. And it's just all of these little things that have got in the way. But the main one is, we already have touch events in all the major browsers except IE. And pointer events are not good enough to justify kind of throwing that out, because we would have to support for ages for all the sites anyway. And the good news as well is Internet Explorer, they recognize that touch is not going away and they are going to implement it as well. Hooray. I wanted to get something else off my chest. Oh, no. Not again. I know. I know. And I want to talk about getting undressed because it's not something I'm very good at. It's not something I'm very graceful at. But we bonded over something about this. Yes, we did. And I wanted it to go over it again, because the final moment of undress, which is when I've gone through the clumsy uncool underwear down, and then what happens. You absolutely have to do a flick with your foot, whoop, catch, and then slam dunk into the wash basket. And then all of a sudden, all of the clumsiness Yeah, it's gone because you're naked and cool at that point. Yeah. You're the coolest naked person in the room. Right. But I was at home doing clumsy undress and then the recovery, whoosh, boom. And I thought of you. Paul. Naked Paul. How am I expected to live my life? Now, we get an API, the web smoothness API. I have been a bit worried about your little peanut head in winter. And with it coming up to Thanksgiving, I thought, well, I'm thankful for Jake. So I got you a present. I bought you a hat. I have a hat. Oh my word. It's both on brand for Thanksgiving. It's all I hoped for and more. What do I do with these? They're going to chafe. The network people for a long time have had all the fun. And now it's the runtime time. We've got a new API. It's the web smoothness API. The web smoothness API? Please tell me it's just web smoothness true and then the web is smooth. Yes. Now, the problem with that name kind of came up in the feedback from other vendors. And they said no, actually, it isn't that. Because it's about measuring information. It's not about whether you're going to switch on smoothness. And it does sound like that, doesn't it? So it's actually been renamed to the frame timing API. So it's going to give us some of what we have for the network API but for rendering? Yeah, pretty much. So I think most people are used to the idea that they use something like DevTools Timeline. They get all the records, like what's your frames per second, but that only applies to the machine they've got, right their desktop machine, their phone, whatever they've got on their desk or in their lab. This is about doing it at like an API level, so you can do it out in the wild. So all your users, you could, in theory, measure your transitions, your animations, your scrolling, all those things, and start to get a lot more data about what's going on in your main thread, what's going on in your compositor thread. So you could use this to, say, find out in combination with the user agent string find out on a particular device that you've never even tested before, maybe you've never heard of before, but you have a major performance problem there. You may not even do it through the UA string. Because you can collect these bits of information and beacon them back to analytics or something like that. And it will do all that hard work of what device it was, or where it was in the world, and all those things. And you could just beacon back events and say, well, look, I think it was 60 frames a second. And then you could slice the data however make sense to you, really. So how can I tie these events back to the elements that are causing the problem? Does it tell me which element has been drawn, which element's been composited? Nope. So the API is actually quite low-level, I suppose. And it doesn't say what was going on, because the browser doesn't really know ahead of time what makes sense. So it just kind of goes, here's what the main thread was doing. Here's what the compositor thread was doing. And you're responsible for marking those areas yourself. And the spec itself is still in flux, right? So there's a lot of opportunity for developers and other vendors to kind of come back and bike shed it until we get to something we think is great. But at this point, hopefully, there's enough base information in there and in the API that people can start using it, start pulling data from the works. We've heard so many times, it's so hard. I do the measurement in my own machine, but I don't know if I've actually got runtime problems out in the wild. I know this for network because I've got webpage tests. I've got all these other APIs. So this is the first API we should get for this. It's very exciting. Do you give them feedback to the stuff? Where is it? Is it W3, is it W3. There's a W3C repo/frame-timing and all the issues on there and there's an explainer doc and the latest draft of the specs. So, well worth checking out. Real world analytics for rendering. Woo-hoo! So it's been conference season. So I've been doing a lot of traveling. And so you've got your suitcase full of clean clothes. As the week goes on, they become soiled by your personal wearing. They become soiled. Maybe time to go and see somebody. There's just general personal soilage. Oh. Let's move on. So we were speaking about getting undressed. You do the flick off, catch. Where did it go? Oh. Into the suitcase? Not with your clean clothes. You monster. No, you unpack them like a grown-up and you put them in the drawers. They're folded in the drawers? That's where stuff gets forgotten. Your clothes, all nicely folded already, stay in the suitcase. So I have a solution. I take with me a bin bag. And that is where the dirty clothes go. And this has many advantages, right? Because you put them in there. It's a separate place for them to go. Keeps them separate from the clean clothes, which are all nicely folded in the suitcase still. And it also locks the freshness in. But because it's airtight, which is a plus, at the end of the week it becomes negative. Because you need to pack that away. And in order to get it back in the suitcase, you need to lose the excess air. No. And you go for a process that I've come to know as stinky bagpipes. You get to play a sad, sad song. OK, Paul. I want to talk to you about font rendering. Ooh. OK, Paul, I want to talk to you about font rendering. Ah! So you visit a site. Everything downloads the HTML, the CSS, the JavaScript, but not the font for the content. What happens? You'd stare at a white screen normally. Well, it depends on the browser, you see. So in Safari, for instance, it will give you all the layout, everything, but it will block rendering of that text. I thought it did that in Chrome as well. Chrome does something similar. We used to do exactly that. But we took a cue from Firefox, and we decided we'll have a 3-second timeout. And then we'll render the fallback font, and when the new font comes in, we'll swap it to the new one. I definitely have two problems then. One You have way more than two problems, but I guess you're talking about two specific problems. To this, yeah. I mean, that's all the therapy time we have for today. Hahaha, folks. Firstly, 3 seconds feels really arbitrary to me. I'm not sure where that comes from. I trust they did research. And then the other thing about it is switching fonts really bothers me. Like if you're halfway through reading a sentence and then the font changes, it's got a completely different metrics, then [POOF] what's that? Yeah, that's horrible. Words can swap from one line to another. It's Ew! It's bad. So I think this is part of the promise is that there is no one true answer. Like even what we do, you know, what Firefox is, what Opera does, it feels like a compromise, which is sometimes the worst of all worlds, right? We've got the delay. We also have to swap sometimes. Yeah. OK, fair enough. Thankfully, and the new CSS property is arriving. Well, I say it's arriving. It is being proposed. OK. So it's a bit early to say it's arriving. Yeah. Wee! It's a proposal by Kenji Baheux and Ilya Grigorik It's on GitHub at the moment. Oh, those two. The worlds of performance and funk combined. Ah! But it's a CSS property font rendering, and you get to pick what strategy to use. Like how long do you want to block for? Do you want to swap? Do you want to use a fallback and then swap the new font in? It also gives you the option if you use another technique. And this is one that we've seen pioneered by I think it was The Guardian that did it first. They use the font if they have it, like if it's in the cache. If it's there, they'll use it. If it's not, they just go for a fallback. They download the font, but they don't swap. They download it. They put it in local storage for next time. OK. But this is a great example, I think, of the extensible web that we've seen people do this. You've always seen The Guardian do it, Smashing Magazine do it now as well. And other people have you know we've picked up on it and think, well, let's remove the bad bits. Let's avoid the amount of code we need to write. Let's avoid the local storage bit. Let's have a CSS property for it. Love it. I've been at a few conferences recently. Yep. And you know how the conference after-party is a great place for developers to come together and chat about things. So we'll put the music really loud to really get the conversation flowing. Exactly. So nothing says quality conversation like shouting at another human being from a couple of feet away. Right. So I was chatting with this guy, and he was giving me his opinion on a thing. And as he was shouting, a bit of spit came out of his mouth. Oh. Where did it land? In my ear. It was a shot that Luke Skywalker would've been proud of. Use the force, Luke. And you know that if like you get water in your ear then sounds sort of. There was so much spit in my ear that that happened. Go on. What was your exit strategy for this, then? Well, no, It was really just to kind of politely sort of go, no, yeah. Yeah, no, that makes sense. You should do some proposing. You should definitely write that up. I'm just going to the toilet now. I'll be back in a minute. And then a calm, collected walk. Don't run. And then as soon as the door opened, run to the sink and like I've got to get this out of my head! Hodge podge. It's a dangerous world, conferences. Yes. Merry Christmas! Yay! It's the Christmas special, so we've put on some Santa hats and we've got some sleigh bells. So I had an idea. Thought what we could do is we could talk about 2014. what is your, what is your highlight what gets you yay about 2014 web? I thought we opened strong by removing the 300 millisecond click delay. Did that happen in 2014? It landed in stable in 2014, so it definitely counts. OK, that's not a cheat, that's just a bending of the rules. No, it's 2014 when it landed in stable. That's the rule. So rather than double tap to zoom, if we know it's a responsive site, then we just remove the 300 millisecond delay. It used to be that you could only do that if you disabled pinch zooming, which is we were punishing people for making accessible sites at that point. For me, web components big deal. Obviously, first through Polymer, but generally speaking on the platform itself you got Custom Elements, you got HTML Imports, got Shadow Dom, you got really nice ways for developers to start encapsulating and sending out their stuff. So I like web components I think they're a good move for the web. It's been a good year for fonts as well. We've got the font loading API which is it gives you events when fonts load, which is handy if you want to do something different before the fonts load in a document, but also excellent if you're doing canvas work. OK, fair enough. Moving on, web animations. See, so we did In Chrome there's a lot of re plumbing to kind of put CSS transitions, and key frame animations through the web animations back end. So all this stuff under the hood got rewired, and now all the web animations APIs are starting to land on top. I think in the last week, we got the ability to pause, and rewind, rescrub the slow the timing down, all that stuff. So that's amazing. And in dev tools, it's not landed yet, but there is going to be an animations control feature where you can scrub animations back and forth, see which animations are playing per element. You can see what the value of all the animations are, so that's amazing. In terms of Evergreen, there's is a point to be made there. We finally have it for WebView. The WebView. Yes in Lollipop, we're got the auto updating web view, which is very exciting. All these new web features because developers, like native app developers, they seem to use the WebView in places where, well some people are going to use it for entire apps, some people are using it just for smaller parts of their apps. But they're getting the latest and greatest. And that's actually a really nice thing. It just brings that web magic, the Evergreen mindset, a little bit into that native world. And when we did that, I thought, about time that that's updating. I heard that sentiment quite a lot as well, but you made a really good point. We're the first people to do it. There's no other platform that is shipping an auto updating WebView. Oh that open source success story of the earth the picture element. Ahh. You have ice. It is crowdfunding. The man's a hero. web, pretty pretty good. Doing all right. Yeah. But. 2015. 2015. Get in. I think the most important thing for 2015 is ServiceWorker. It's ServiceWorker I'm glad you said that. One hit wonder. It's the start of a massive land grab into what is being previously considered native-only features. So I went onto the guiding website a couple days ago. It had this banner that said, download our app because you get offline and alerts. I was looking at it going, 2015, the web gets that. That's great. So exciting to lookout for 2014 on the web. Yay. Cracker? Yeah. Now, I discovered that many folks around the world don't observe this tradition. It's a piece of cardboard that makes a pop sound when you pull it, and inside there's a paper hat. Let's pull a cracker. Are you ready? Are you ready for this? So the rule is that whoever gets, whoever ends up with most of the cracker is the winner, right? Is that the? Yes, that's fair, and then you get the present inside of it. Excellent. Yay, winner is me. I guess another part of the rule is that British people thrive on disappointment, and so the thing you get inside a cracker is part of that. So yes, a plastic frog, excellent. That's something I will cherish for the rest of my life. What other delights are in here? The hat. It just screams quality, doesn't it? Well, the other part of it that you get the joke. These are special web crackers. Oh. So there may be webby jokes inside. OK, here we go. How do ghosts find things on the web? They use Ghoul-gle. Wow. Classic this. Which HTML element did the bride wear to her wedding day? Address. Oh, the address element. Yeah. Why was the accessibility tester angry with the removal men? Because they forgot about the long desk. On the image element It's a long description. Long desk, that hilarious. All right. Why did MVC framework blush? Because it was Ember-arrassed. Ember-arrassed. It's like embarrassed. Brilliant. Why did Mr. Gyllenhaal not buy John Rezig a Christmas card? Because he makes jQuery. JQuery? Jake weary. Oh, fantastic. It's a laugh a minute around here, isn't it? Yeah, Merry Christmas, ya. So it's my turn to get things off my chest I feel. I recently built the Chrome Dev Summit site.  And a mighty fine job I thought you did, as well.  Thanks, pal.  That's all right.  But on my journey through building that, I discovered some gotchas. First up position fixed tell me what you think position fixed actually does?  Takes an element out of document flow, and it positions it relative to the viewport.  The what?  The viewport.  The viewport. The viewport.  Right.  Right.  Was I right?  When you apply a position fixed to a child of something that has a transform so you got another one with a transform and another element inside, which is position fixed. The position fixed behavior changes. The transformed element becomes a new initial containing block.  Whoa. What?  Yeah, it's like a new viewport inside the viewport. So the way I did is it, because I had these cards that were transforming, at the end of the transition, I'd scale all the transforms, so that I didn't see weirdness on the content so frustrating. Gotcha number two pop state.  Oh, yeah, I've done pop state before.  Yeah. Did you know that it restores scroll positions?  No, actually I didn't.  Right. So this is bonkers to me. You're doing something with the history API, you're pushing states on, you're popping states off, because you're handling app state yourself. But what the browsers all do is they go, I know what you want to do. I know you want to restore the scroll position at the point at which you did push state. Which is, if you're doing something async, right? If you're doing something  Which is what I've always done in the past.  yeah, then all of a sudden, your page would just snap down to its previous scroll position. I thought I can fix this. I'll work around it gun fingers. pow pow.  What I'll do is I'll have a single listener for scroll position, and when it switches, after the pop state, it'll do one scroll. I'll reverse it. me back.  And they'll be like, haha, never happened shazam. No. Because Chrome does that it does the scroll after the pop state. Firefox does it before. So you actually don't know where you scrolled from. You just know that you're pretty certain you're not in the scroll position you were before. Talking of scrolling last one body. Did you know you can't stop the body from scrolling?  That's the name of my next album, actually.  Yeah, Jake. That's great.  Mousewheel events?  You could, but that's not going to work on mobile.  On mobile which you have touch events.  No. No.  Because then you're going to have to re-implement all of scrolling.  All the fling physics-y stuff.  And if you do that, you've lost performance, lost everything, your life.  Forget it. Not doing that. Don't like it. Don't want it. Because what happens, again, these cards, they expand. They've got scrollable content inside. When they reach the bottom of their scrolling content, the body goes, I will deal this. I'll start scrolling now. Well, there is an escape hatch, an ability for a developer to go, you know what? I want to take control of this. I know what's supposed to happen here. I will deal with it. So extensible web says, nah.  Nah.  Right? Exactly. Good news, though. In spec land, in discussion world, there is before scroll, which is an event, and its corresponding CSS properties around what scrolling should be blocked on. But the default behavior still remains as it is today. It gives developers more options to say, I know what I'm doing. Please let me put the car into my manual  Manual.  or stick shift, as it were, and we'll go from there. So from an extensible web point of view, yay.  Yay.   So we're back.  Yes.  And I've grown a beard in the interim, where I think gives it a distinct, you know, distinguished look.  It's just to have some hair, right, in a place.  To be fair, I think it's a character progression. Those who are more important to the plot, they obviously progress more than perhaps, say others, because the only progression you're offering right now seems to be a plaster on the side of your head.  So the plaster, yes.  Yes, the plaster. What are you doing, exactly?  Yeah, I had a shaving accident.  What are you shaving up there for?  It's not really. Actually, I had an allergic reaction to some sun cream.  Really?  And of all the things, I need sun cream really badly. If I'm developing an allergic reaction to that, I am properly screwed.  Yeah it's like everything hates you. At this point, it's just like something's just trying to fry you to a crisp. You're basically stuffed.  I'm speaking at a conference that  It's not in Barbados, is it?  It's in Austin in July. Yeah, I know, right? I am going to walk off the plane and then just BOOF! I'm just going to be turned into a shadow on the side of the wall. That's me going  Some smoking trailers.  Yeah. Web versus native. That's still getting a lot of air time, and that bothers me.  It will until native dies.  Yeah, you fall into that a little bit of the zealot camp sometimes, don't you?  Yeah, OK.  You're like, the web should do everything.  The web should do everything.  No, it shouldn't.  What shouldn't the web do?  There's nothing wrong with native taking over  Whoa!  when you want closeness to the platform in question. That's OK. There's nothing wrong with that. There's some stuff that native is actually good for today.  What? Tell me what it's good for. What do you use native for that can't be done on the web?  I think offline is still not sorted, and I think notifications  Offline's sorted. We fixed offline. ServiceWorker shipped at the start of the year.  Not for iOS, right? Like, for example, if you talk about what apps do I use on native, it's Tweetbot is one of the most obvious ones, email as well. I'll do that. Again, it's offline, and most of them give me notifications like Tweetbot will let me know when I've got a direct message or when somebody @replies me, which the web can't do.  We've got notifications as well. Chrome 42.  What the web will do.  But that does do I mean, OK, it's only on Chrome at the moment, Firefox coming soon, but that's the web doing it, right?  Yeah, but today, it's still a bit iffy. Given a long enough timeline, yes, I think the web will take those bits, and there will be more things that can be done on web that you would do on native today, right? So that's absolutely fine. What I still think is there's this sort of smooth on-ramp for the web, right? Where it's like you give somebody a URL. There's no app stores. There's no play stores. There's nothing like that.  You inherit shareability by just being able to give someone that bit of text, and they will get to see the thing you were looking at.  And so there's no friction there, right? Just go to the URL, do the thing. Hopefully it will answer your question, right?  Yeah. Yeah, and when we compare native to web, I feel that we often compare it like no-cache web to installed app when really you should be comparing non-installed app. You have to go to the app store. You install that megabytes worth of stuff, whereas the web, you just get your own get the content.  Right. But at the same time, that's slightly ludicrous to say, to use this app, you must first install this app, right? But that's the web's model, is to say, you've got to go from cold. We assume you've got nothing. With native, we're going to assume you can, that you've got it already.  For me, that's the joy of the web. As you say, someone gives you a URL, and you could be with the content in just seconds later. Even though you've never been to that site before, you don't have to go and install megabytes of stuff. You just get it. I really hate that so many websites circumvent that part of the web. You'll get a website which wants to wants you to answer a survey before you can see the content or wants you to download the native app before you can see the content.  No, no. Always no, no, no. I'm not here for your survey.  Have you ever seen someone trying to take a survey in London Bridge?  No.  Well, they're standing there, clipboard in hand. Everyone comes off the train, but no one wants to stop. Everyone knows where they're going. You see the look of horror on the face of the person with the clipboard. It reminds me of that scene in Lion King where Simba's in the canyon and all the wildebeests come down on them. And I say don't when people want to do a thing, they've got a destination to get to, don't start getting in their way.  Fact.  And this is why we hate the kind of do you want to install our native apps? No, I've gone to the URL with the bit of content that I would like. Why can't you just show me that?  Yeah, yeah. Finally, on the whole web versus native thing, the thing I do definitely love is that there's no SDK download for the web, right?  You don't have to build the Eclipse monstrosity thing. You don't have to dump that on your machine. I mean, even things like Xcode, how many gigabytes is Xcode?  Five or six. I can't believe I actually knew that. That was a little bit weird.  And with the web, it's just a text file.  Yeah.  You can write DOCTYPE, HTML, Hello World  Don't have to do the DOCTYPE, if I'm honest.  I think you do have to do the DOCTYPE.  Don't have to.  You don't want it in quotes, but OK, even then, you could have something working in a browser. It's super easy to get started.   I had this experience at work once where I was leaving work. I had my headphones in, I was listening to some stuff. And I went to the bathroom. I went to the urinals, because I needed to do a wee. And  Thanks for that update.  And as it was happening, I moved my hand, and I knocked my earphones.  No, no, no.  Yeah. You know what's coming, right? And it was just like this slow motion of them falling. And there was peoples at the urinals next to me, so I couldn't do anything about it, right?  You didn't knock it into  Well, no, no. Well, if Ghostbusters taught me anything, don't cross the streams, right, is the key rule. No, I couldn't catch it. But once they landed in there, they're ruined, right?  Yes. You're not going to shove those back in your  So I just carried on. And it was just this really depressing moment where I just continued to urinate on my earphones.  How is this in any way related?  Because that reminds me of so many websites. I've been being reminded of that moment when developing so many websites. And it's because if something like that when you're developing for i6, it's like, why even try at that point? It's already been pissed on. They're already ruined, so why not just carry on? Just to carry on.  Just make it.   I still think the web has the simplest Hello World, right? It's just doc type, Hello World, and now you have a web page. It's all you need.  Or is it? No.  Yes it is.  No it's not. No, because we've made it impossible, frankly.  We haven't made it impossible.  Yes we have. To get going with the web, first install NPM. Then probably install Bower. And then you install Gulp or Grunt or both. And then download all the modules you need. And then you wrap bizarre things like [? Watcherify ?] around Browserify around BaileyFY. And then stand on one leg, face due east and then, and only then, are you good enough to build for the web.  What you're talking about there isn't building something for the web, it's being excellence to the web. It's making the web really good. And I know that's different. OK, go on.  Because no. Because every single tutorial, when you get past their little world, it's going to say, in order to proceed, you're going to require these tools. You're making it sound like there's a kind of on ramp, where we gently go, I know you've got this far with the web, but now you need to just ease across to these tools. Oh, and they're lovely and easy to work with. No, no, no. We just go, to begin, first to invent the universe. I do get it. And that like, I don't want to say that the tools are bad, the tools the wrong. But I am concerned that the next generation of developers is going to get somehow left behind. It feels like we're not taking enough care over that journey that people are going to naturally have to go through. I saw this with Flash, actually. When ActionScript got so advanced, and the tooling got so advanced, that it was just a brick wall. And one of the great strengths of Flash is that it had all these designers coming in early on. People who were naturally, sort of inclined to code. But they started to dabble, and then the dabbling became good and professional. And then before you know it, you've got these people who would have never described themselves as coders, doing these amazing things. And they bring diversity. They bring interesting things.  This is not a new problem with the web, though. You go onto Stack Overflow, and you find the question of how do I hide an element on the web. And the answer is wow, it's just a single line. And that single line uses  jQuery.  jQuery! Absolutely, it does. And so we're just kind of switching out jQuery as a prerequisite for something on NPM now.  No we're not. No, because with jQuery, at least I can go there, and I can hit a big download button. And I can get jQuery. I can include it with a single line that says source equals blah to the jQuery, and then off I go. What we're talking about is the fact that you have to first of all get all these command line tools. And you have to go crazy over this whole pipeline before you even are able to get to Hello World. We can't forget that Hello World experience, because that's how people get started. If not, we run the risk of being essentially making an SDK for the web.  I think you've forgotten about the main problem with this. And it's now like if we want people to be developing for the web, one thing they have to learn is Git.  I don't think that Git is a big deal, actually. You don't have to.  Are you sure you're not just forgetting how difficult the learning curve was.  My Git workflow is typically to type tower, hit Enter, and then use a GUI.  I still think you need to understand how version control works. Not just normal version control, but Git version control, where it's all you can re-base. But even if you amend the last commit, it's actually creating a new commits, because are mutable things. People need to understand that, just to start with the web.  They don't have to. Again, you could download jQuery. Just download, right?  And this is what we need.  Go on.  No. Exactly what you say. Is when someone has a Git repo with a library or something, there must be a download link. Even it's just linking into the source, a single source, or in a disk folder, like a build version. There should be a click there that someone could copy and paste that JavaScript and now they're good.  Right, because if you don't want to go in for any of this, and you just want to use this library, there is a better way here. Where you can include in all the workflow and do that. And it is a good thing and a professional thing to do. If you just need it, go to the disk folder, get the thing, use it, smile a happy smile, and that's your day.   This is one of the things that's changed on the web since the start days for me is you now need to set up a server to do anything. It used to be that you could just run the stuff on your file system. That doesn't work anymore because the cross-origin rules have been, quite rightly, really tightened up in browsers. Like if you're on the file system, you can't really contact anything else. It's all treated as a separate origin, which it should be, right, because you don't want a web page on your machine being able to go into your passwords folder or whatever. But that's it. If you get started with web, all you need is an HTTP server running on local host and off you go.  No. No. Again, no. Always no with you. Right. Fine. It works on your machine, and then you upload it to your server and it goes, ha ha, no, because it's no longer HTTPS. I've white listed local hosts so you're good to go, but now, it should be Service Worker, push notifications, all those lovely new things you wanted, uh-uh.  Paul hates security on the web.   Again, HTTPS is just too difficult and there's so many features being gated on HTTPS right now that it's a bit depressing. You know, why? Tell me the answer.  HTTPS is super important. I think if there are two sources of information that are otherwise completely equal and completely identical, except on one of them, you can trust that you'll receive it unmodified, course that's better.  I'm OK with it from the user perspective. It's a good thing to ship for users. But but it's not  Button.  Button.  He's going to press the serious button now. This is your disapproval button.  This is the aargh the rage button. Because the hosting that you get is not going to give you that by default. It's too hard, right? If you go into DevOps and you run your own server, you're by proxy saying, this is something I am willing to take on as my responsibility, right?  Yeah.  OK? But if you don't, and the standard issue developer that I am, I don't want to get into DevOps. I don't want to do that. I think the default option from my host should be HTTPS. It shouldn't even be a thing that I have to opt into when they go, you get PHP 4, 5, MySQL, as many as you want, oh, and you get SSL just by default because you're a human being who wanted to get hosting from us.  I think the big companies such as Google, they need to find a way to, rather than punishing the developer, they punish the hosts. Because there's a lot of hosts still using HTTPS as a money spinner, whereas with things like SNI, it can be super cheap. OK, with SNI, you lose Android 2. Android 2 doesn't support it. And you also lose Internet Explorer on XP, I think. But those things are going away. It should just be free, as you say, with every host.  HTTP at this point, for me, should be more like a bug. It should be considered aah. That's  Now, there's been some discussion around that and there's been some people suggesting that all new web features should only land on HTTPS, whether it's security sensitive or not. I disagree with that quite strongly.  I think if 95% of the web was HTTPS, fair enough, but it's not. I think we've got to get more people as the default before you start switching things off properly. I can see the new features, the ones that are security sensitive particularly.  I think it's fine for security sensitive stuff. Service Worker is HTTPS only for a good reason. We tried to find a way to make it work with HTTP. There wasn't a way. But for features that don't need it, like we're getting a new media API. So the Play, Pause keys on your lock screen and stuff, we're going to bring those to the web. That doesn't need HTTPS.  No. I mean, it would be ludicrous if somebody said, WebGL or IndexDB, they require HTTPS because they're on the web. It doesn't make sense.  It does sort of feel like the standards people wagging their fingers at developers going, eat your greens or you're not allowed the pudding, where the greens are HTTPS and the pudding is new web features. I don't think it's a constructive way to build up the web.   And we're seeing a lot of frameworks now that they are moving to a model where they could do server rendering as well. I bought a PS4 recently. I've been going on about it. And I was looking at some of the literature that comes with it. One of the big things that they advertise is that, hey, did you know that new in the PS4 is you can, while you're downloading level one of the game well, as soon as level one is downloaded, you can start playing it even though levels 1 to 99 are still downloading.  Wow.  And that's what I was thinking of. Wow, this is the PS4. This is the absolute height of technology. But the world's been able to do this for 20 years.  I think there's a lot of skill, though, in dividing up your web app into things that need to be there in the initial burst, and then things like the level one stuff, and level 2 through 99. I still think that's much too difficult for us to get our heads around. It takes a lot of planning. And it's OK if it's just sort of a one-person thing, where they, like, I do the design, I do the development, I do everything myself. But if you're not that person and you've got a big team, having everybody think about what is level one, that's really hard. Because you've got to understand exactly how the web gets built before you can get there.  But the benefits are huge. On this blog post I did about progressive enhancement, someone, an author of one of these big web frameworks  Who shall not be named.  We won't name them. But they bombed the comments with like, well, this is nonsense. My framework is excellent. I looked at the documentation for their framework, which uses the framework as an example of the world.  And on 3G, their time from request to some content on the screen is seven seconds.  Ooh.  But even with a full cache on a fast as you like connection, it's still three seconds, because they're CPU-bound. I know, right? It's just like and as soon as I saw that, I was just like, win this argument, then. I can do this with data. And it was just normal content. I mean, there was a few JavaScript things, like open this, collapse that. You could do that all after the fact.  So I guess this comes back to the whole like, Twitter did this years ago, didn't they, where they went, hey, we've shifted to client side and everything is awesome. And then they went, actually, doing what the web was doing, which is serving some HTML over the wire in the initial request, that's where the cool stuffs are.  Yes, this is my progressive enhancement rant, clearly, right? But what was it? It was like a six times speedup they saw so that  I don't know. I don't actually remember. I know they did say, we've gone and done it because performance, yeah.  But then, to be fair to frameworks, like, I do like how they're stating to go with this server-rendering approach, what they call isomorphic.  Yes. You got it right.  I got it right this time.  Yeah, every time you say it, it's like pain. But that's this feels like the right approach. I feel like it's  Really?  It's a Band-Aid over the solution, over the problem of slowing everything down.  Right. They made this problem, right? This whole thing was avoidable if you just did what we did, right?  That's it. By leveraging good caching, first render stuff, and service worker, your performance problems are solved.   You see, you've got that look on your face, because you know you're winding me up.  Yes, I do.  Yeah. Yeah, you are. All your problems are gone.  So what's your problem, then, Paul?  My problem with this is the page load time is this proxy for all your performance problems are sorted. No, no, and again once again, no. Right? I've got two major issues right now. One is to get good page load time, people defer everything to DOM content loaded.  Right.  And they or body load, or whatever. And they create I like to think of as a 9:00 AM rush hour problem. They all go, you know what we should do? We should make sure the roads are all clear until 8:45, and then everybody should go on the roads.  So what's the effect of this that you're seeing? It's that as you as the page loads, it has a moment of jank?  More than a moment, actually. It's like honestly, it can be at least several seconds. Because we know that when people first hit a page, the first thing they try and do is tap, or scroll, some kind of interaction. And it's the very time that we've all chosen to do all our work.  Yeah.  And it drives me mad. This is not you can get a good first paint, and then completely hose the user's expectation by doing this. And then the other thing that bothers me is this, kind of, disregard for anything that happens after the page load. Like, I've got it on the screen. It's now the browser's problem if it doesn't scroll well, if it doesn't transition well, if it doesn't stick to finger when they're interacting in some ways.  Well, 50% of the answer will be, have you tried virtual DOM?  So vDOM. All right, fine. I think vDOM is actually a very clever idea. Because I think what it's doing is it's making sure you don't shoot yourself in the foot.  This is the key to it. I don't know. When people say that to me, it feels like I say, oh, god, my train journey takes quite long. It's like 40 minutes. And people say, ah, have you tried wearing better running shoes? It's like, well, I'm still going to be there on the train, with those running shoes. And so if things like React that do the virtual DOM thing, they are still going to work with the DOM?  Yeah.  Like, if you have 100 elements to create on the page, that will be slower with React.  Yeah.  Because React is on the top.  Yes. And also, I've seen timeline traces where all the work was React. That's not React's fault, but it struck me that the developer might be thinking, well, essentially all the work I do in React, or all the work I do with vDOM is free. It's only the bit at the end that I have to pay the cost on.  But where things like React really come into their own is where you can just sort of you can create a whole load of new objects to represent the DOM and say, this is what it should look like.  Right.  You can write your code really naively, and React will cater for that. And rather than create a whole set of corresponding DOM elements, it will take what's already there, move that all around, change the order, and just create the new stuff it needs. And that's the sort of practical performance benefit. It's not the DOM that's slow. It's kind of your use of it.  I think exactly. It's very much your use of it. I think it's very nice to have the headlines, like, the DOM is slow. Or always use CSS animations. But, no. Because it completely misses the nuance.  This is something I've been kind of exploring more and more recently is that displaying what looks like a complete interface, but it's not actually ready. Is that OK? Is that something you  Yeah. Well, so long as the thing that they want to interact with will work.  This is the problem with what Apple recommend with their because they have only a few dimensions of phones. You can include essentially screenshots of every device as your initial render. The problem with that is that it won't be clickable. So I think what they recommend is just something that has the colored bars and stuff?  Yeah.  I think we should be doing more of that on the web. But not with bitmaps, because windows can be any size. But with something with just a very small blob of CSS, a little bit of HTML and Flexbox, or whatever it is, just to do your sort of basic  Bare bones. Yeah. I think that's absolutely fine. Like, that has to be part of it. Perceived performance is a huge part of this whole discussion. And I think as Service Worker is more widely used, as we get to this kind of fast bootstrapping offline-y world, where people are sort of tapping on things from their home screen, well, it's all this bit afterwards that actually is going to shape user expectation. That's the bit they're going to notice. They're going to decide whether or not to use your thing not because of how quickly it loads, because that would be a fraction of a second, probably. But it'd be all that other stuff afterwards. It says, what do they care about? What do they actually notice? What do they perceive? That's the thing to target. And, of course, on the developer side, this is the idle stuff. There's that kind of what can we actually give to the user to make them feel like they're getting the right response in the right time? But it may be that there's a bit of sleight of hand on our part, for sure.  Hm. In five years time, what is your idea of Web heaven, Web hell assuming everything goes right, everything goes wrong?  Yeah, I'm going with utopian and dystopian, because it feels more Blade Runner-ish.  Yes. Oh, great film, yeah.  No. It's not a good film. It's a terrible film. I don't even know why I brought it up. I don't even like the movie. I watched it, right? It's one of those movies. I'm one of these people that people go, oh, you've never seen that movie? You are terrible human being.  I'm still getting past I don't like Blade Runner.  Yeah. Right. This does come back into that. There are loads of movies where you get told that it's a classic and a must watch, ooh, all that. So you then go, fine. All right. Fine. I'll buy it. It's $5.99 on Play, HD version, because you've got to go HD, because whatever.  Of course. Rules are rules.  Rules are rules. And you do it. And you sit down to watch it, and you've got everything perfect. It's all set up. And you watch it and you think, this is pathetic. This is a rubbish, rubbish movie. Highlander, also terrible, with Sean Connery's honestly, I've never heard a more abysmal Spanish accent. My name is Juan Sanchez Villa Lobos Ramirez. You're not Spanish  No, no! Stop it! Stop, stop, stop! You're trying to say that Blade Runner is bad because Highlander is bad  No, no, no.  You can't do that. That's not allowed.  I'm saying there's a principle at play here that nostalgia applies to movies. You bring it back in to your Blade Runner's and you look at it, and you go, that's just not a good movie, with Rutger Hauer going walking around, trying to take out Harrison Ford.  It's got Harrison Ford in it.  Yeah. Now I'm told that I watched the wrong cut of that movie, because I watched the director's cut.  Yeah, because you watched Highlander, clearly. No, I watched  The worst thing about Blade Runner was the Spanish accent by Sean Connery. What was that? What was that?  That was my impersonation of your impersonation of Sean Connery's Spanish accent.  That was perfect. Absolutely flawless. Anyway, in any case, you come back to it and you go, Blade Runner is not a good movie. And as I say, I watched the director's cut, which I thought would be the ultimate cut, the one that's worth watching. Turn's out apparently I watched the wrong one. Any movie that has enough cuts to have a wrong one is a movie that clearly they couldn't make good.  Star Wars?  No, they all got better, apart from the bit where Han Solo went over the back of Jabba the Hutt's  Yeah, come on.   But anyway, dystopian, utopian Web. Let's bring that back in.  I don't know if I can trust your answer anymore.  No. But flawless. My take on this is perfect.  So your Web dystopia. Five years in future, the Web is a dark horrible place because all the things that are starting to happen now have just worse, or things that could happen now have got worse.  Then you're the only every time you hit a URL the first thing you see is a door slam, where you're told to download, and you can't skip past it for at least 10 seconds.  Yep, yep. Or until you say to your phone, I promise to download the app later, it has an audio feature.  Well, no. That's the only way you get to the Web experience is by forcing a download or something. Then when the only people who can build for the Web are the elites.  Like the Avengers.  Yeah, like the Avengers. The Web Avengers.  Tony Stark is the only person who can build websites.  Essentially, yeah, because the tooling has become so complex and complicated that only an AI can build for the Web. What else I think would be absolutely terrible? Everything just runs abysmally, because the frameworks are so heavy, and the tooling is so heavy that nothing actually runs well.  And I think that there's sort of knock on effect of that is that if the Web dies, then you're going to see we have a problem today with the amount of operating systems we have with mobiles. And it shouldn't be like that. Because now if you want to start in the mobile space, you have to have a huge app ecosystem already. And that's not going to happen. So I think that problem gets worse if the Web weakens.  Yeah, I agree. I think it's interesting that because you've got these operating systems and what's going to naturally happen is you're going to want these apps to start communicating with each other, or link to each other, or in some other way be a sort of streaming experience or something like that. And you just kind of go, that's the Web. What you're trying to emulate is potentially the Web.  There's XKCD about that. So much imagine if an app could be dynamically loaded, and there was some easy way to transfer it from one person to another. Yeah, it's the Web.  It's the Web. What we need is the Web to just continue to get stronger and to be a part of this overall story. I don't think it's the only part of the story. I think we disagree on that. But I do think it's one very strong and it's a pillar of modern digital worlds.  So Web utopia, then. Five years time, everything's going brilliantly.  Well, you can answer that one. Because I've done the dystopia. I'm quite  You're the downer, along with your I don't like Blade Runner because it's Highlander, Highlander, Highlander.  It's rubbish. Because it's rubbish. The plot took two hours  I don't want to get into it, mate. Five years time, utopia on the Web.  Utopia on the Web, go on.  Utopia on the Web. Five years time. I think we'll see the apps that you and I use today that are native will be done just on the Web, like the Twitter clients, like the Facebook clients, like what other apps do I use? Hangouts. These things can be done just through the Web, and you write it once, and it's working on multiple platforms. That's the utopia. Because we're getting really close there with asm.js. This is one of the things that I know a browser is better at than us. So I thought I would say that's the utopia, just the Web being the first answer, and native being the exception.